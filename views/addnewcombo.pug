doctype html
html(lang='en')
	head
		script(src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js')
		link(rel='stylesheet', href='https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css')
		script(src='https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js')
		link(href='https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/css/select2.min.css', rel='stylesheet')
		script(src='https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/js/select2.min.js')
		meta(charset='utf-8')
		meta(http-equiv='X-UA-Compatible', content='IE=edge')
		meta(name='viewport', content='width=device-width, initial-scale=1')
		title add new combo
		link(rel='stylesheet', href='/stylesheets/bootstrap.css')
		link(rel='stylesheet', href='/stylesheets/spin.css')
		script(href='public/js/spin.js')
		script().
			var maximumNumberOfCardsPerCombo = 7;
			var numCards = 0;
			var opts = {
			  lines: 12, // The number of lines to draw
			  length: 38, // The length of each line
			  width: 17, // The line thickness
			  radius: 45, // The radius of the inner circle
			  scale: 0.1, // Scales overall size of the spinner
			  corners: 1, // Corner roundness (0..1)
			  color: 'black', // CSS color or array of colors
			  fadeColor: 'transparent', // CSS color or array of colors
			  speed: 1, // Rounds per second
			  rotate: 0, // The rotation offset
			  animation: 'spinner-line-fade-quick', // The CSS animation name for the lines
			  direction: 1, // 1: clockwise, -1: counterclockwise
			  zIndex: 2e9, // The z-index (defaults to 2000000000)
			  className: 'spinner', // The CSS class to assign to the spinner
			  top: '10%', // Top position relative to parent
			  left: '20%', // Left position relative to parent
			  shadow: '0 0 1px transparent', // Box-shadow for the lines
			  position: 'absolute' // Element positioning
			};
			var __assign = (this && this.__assign) || Object.assign || function(t) {
				for (var s, i = 1, n = arguments.length; i < n; i++) {
					s = arguments[i];
					for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
						t[p] = s[p];
				}
				return t;
			};
			var defaults = {
					lines: 12,
					length: 7,
					width: 5,
					radius: 10,
					scale: 1.0,
					corners: 1,
					color: '#000',
					fadeColor: 'transparent',
					animation: 'spinner-line-fade-default',
					rotate: 0,
					direction: 1,
					speed: 1,
					zIndex: 2e9,
					className: 'spinner',
					top: '50%',
					left: '50%',
					shadow: '0 0 1px transparent',
					position: 'absolute',
			};
				var Spinner = /** @class */ (function () {
					function Spinner(opts) {
						if (opts === void 0) { opts = {}; }
						this.opts = __assign({}, defaults, opts);
					}
					Spinner.prototype.spin = function (target) {
						this.stop();
						this.el = document.createElement('div');
						this.el.className = this.opts.className;
						this.el.setAttribute('role', 'progressbar');
						css(this.el, {
							position: this.opts.position,
							width: 0,
							zIndex: this.opts.zIndex,
							left: this.opts.left,
							top: this.opts.top,
							transform: "scale(" + this.opts.scale + ")",
						});
						if (target) {
							target.insertBefore(this.el, target.firstChild || null);
						}
						drawLines(this.el, this.opts);
						return this;
					};
					Spinner.prototype.stop = function () {
						if (this.el) {
							if (typeof requestAnimationFrame !== 'undefined') {
								cancelAnimationFrame(this.animateId);
							}
							else {
								clearTimeout(this.animateId);
							}
							if (this.el.parentNode) {
								this.el.parentNode.removeChild(this.el);
							}
							this.el = undefined;
						}
						return this;
					};
					return Spinner;
				}());
				function css(el, props) {
					for (var prop in props) {
						el.style[prop] = props[prop];
					}
					return el;
				}
				function getColor(color, idx) {
					return typeof color == 'string' ? color : color[idx % color.length];
				}
				function drawLines(el, opts) {
					var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
					var shadow = 'none';
					if (opts.shadow === true) {
						shadow = '0 2px 4px #000'; // default shadow
					}
					else if (typeof opts.shadow === 'string') {
						shadow = opts.shadow;
					}
					var shadows = parseBoxShadow(shadow);
					for (var i = 0; i < opts.lines; i++) {
						var degrees = ~~(360 / opts.lines * i + opts.rotate);
						var backgroundLine = css(document.createElement('div'), {
							position: 'absolute',
							top: -opts.width / 2 + "px",
							width: (opts.length + opts.width) + 'px',
							height: opts.width + 'px',
							background: getColor(opts.fadeColor, i),
							borderRadius: borderRadius,
							transformOrigin: 'left',
							transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
						});
						var delay = i * opts.direction / opts.lines / opts.speed;
						delay -= 1 / opts.speed; // so initial animation state will include trail
						var line = css(document.createElement('div'), {
							width: '100%',
							height: '100%',
							background: getColor(opts.color, i),
							borderRadius: borderRadius,
							boxShadow: normalizeShadow(shadows, degrees),
							animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
						});
						backgroundLine.appendChild(line);
						el.appendChild(backgroundLine);
					}
				}
				function parseBoxShadow(boxShadow) {
					var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
					var shadows = [];
					for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
						var shadow = _a[_i];
						var matches = shadow.match(regex);
						if (matches === null) {
							continue; // invalid syntax
						}
						var x = +matches[2];
						var y = +matches[5];
						var xUnits = matches[4];
						var yUnits = matches[7];
						if (x === 0 && !xUnits) {
							xUnits = yUnits;
						}
						if (y === 0 && !yUnits) {
							yUnits = xUnits;
						}
						if (xUnits !== yUnits) {
							continue; // units must match to use as coordinates
						}
						shadows.push({
							prefix: matches[1] || '',
							x: x,
							y: y,
							xUnits: xUnits,
							yUnits: yUnits,
							end: matches[8],
						});
					}
					return shadows;
				}
				function normalizeShadow(shadows, degrees) {
					var normalized = [];
					for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
						var shadow = shadows_1[_i];
						var xy = convertOffset(shadow.x, shadow.y, degrees);
						normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
					}
					return normalized.join(', ');
				}
				function convertOffset(x, y, degrees) {
					var radians = degrees * Math.PI / 180;
					var sin = Math.sin(radians);
					var cos = Math.cos(radians);
					return [
						Math.round((x * cos + y * sin) * 1000) / 1000,
						Math.round((-x * sin + y * cos) * 1000) / 1000,
					];
				}
		style(type='text/css').
			.list {
				font-family:sans-serif;
				margin:0;
				padding:20px 0 0;
			}
			.list > li {
				display:block;
				background-color: #eee;
				padding:10px;
				box-shadow: inset 0 1px 0 #fff;
			}
			.avatar {
				max-width: 150px;
			}
			img {
				max-width: 100%;
			}
			h3 {
				font-size: 16px;
				margin:0 0 0.3rem;
				font-weight: normal;
				font-weight:bold;
			}
			p {
				margin-bottom:10px;
			}
			input {
				border:solid 1px #ccc;
				border-radius: 5px;
				padding:7px 14px;
				margin-bottom:5px
			}
			input:focus {
				outline:none;
				border-color:#aaa;
			}
			.addCard{
				margin-left: 20px;
			}
			.select2-container{
				margin-bottom:5px;
			}
			.comboName{
				width: 125px;
			}
			.preview{
				background-color: grey;
				width: 223px;
				height:310px;
				border-radius:10px;
				box-shadow: 2px 2px 0px 1px black;
			}
			

	body
		.container
			hr
			.row
				.col-xs-6
					h1 Add a new combo to the database
				.col-xs-6
			hr
			.row
				.col-sm-8.col-lg-7
					.row
						.col-xs-3
							h4 Combo name: 
						.col-xs-9
							input.form-control.comboName(type='text', value='comboName')
					.row
						.col-xs-3
							h4 Type of combo:
						.col-xs-9
							select.typeOfComboSelection(name='typeOfCombo')
								option infinite mana
								option infinite damage
								option draw library
								option lethal damage
								option storm
								option graveyard
					h2 Add cards:
					.row#row1
						.col-xs-3
							h4 Card #1: 
						.col-xs-9#newCardSelectionLocation
				.col-sm-4.col-lg-5
					.preview
						img#targetImage(alt='')
						
			.row
				input.btn.btn-primary.btn-lg(type='submit', value='Add a new combo')
				input.btn.btn-secondary.btn-lg.addCard(type='button', value='+')
		hr
		footer.text-center
			.container
				.row
					.col-xs-12
						p Copyright Â© MTGComboLibrary. All rights reserved.
		// Include all compiled plugins (below), or include individual files as needed
		script(src='/js/bootstrap.js')
		script.
			var target = document.getElementById('newCardSelectionLocation');
			var spinner = new Spinner(opts).spin(target);
			function updatePicture(response){
				$("#targetImage").attr("src",response);
			}
			function addCard(response){
				numCards++;
				var $select = $("<select>").html(response);
				$select.attr("id","id"+numCards).attr("class","cardsSelection");
				if(numCards==1){
					spinner.stop();
					$("#newCardSelectionLocation").append($select);
				}
				else{
					var newRow = $("<div class='row' id = 'row"+numCards+"'> </div>")
					newRow.append("<div class='col-xs-3'> <h4 >Card #"+numCards+":</h4> </div>")
					var secondColumn = $("<div class='col-xs-9'> </div>");
					secondColumn.append($select)
					newRow.append(secondColumn);
					var prevCard = numCards -1;
					$("#row"+prevCard).after(newRow);
				}
				$("#id"+numCards).select2({minimumInputLength: 2}).on('select2:select', function(e){
					var name = e.params.data["text"];
					$.get(window.location.href,"getPicture:"+name,updatePicture,"text");
				});
			}
			$.get(window.location.href,"addCard",addCard,"text");
			$(document).ready(function() {
				$('.typeOfComboSelection').select2();
				$('.cardsSelection').on('select2:select', function(e){
					var name = e.params.data["text"];
					$.get(window.location.href,"getPicture:"+name,updatePicture,"text");
				});

				$('.addCard').on('click',function(){
					if(numCards <maximumNumberOfCardsPerCombo){
						$.get(window.location.href,"addCard",addCard,"text")
						}
					else{
						alert("only 7 cards per combo please.");
						}
				})
			});
